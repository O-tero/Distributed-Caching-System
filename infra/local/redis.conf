# Redis Configuration for Local Development
# Purpose: Configure Redis as L2 cache with LRU eviction
# 
# This configuration is optimized for local development with:
#   - Memory limits to prevent OOM on developer laptops
#   - LRU eviction for cache-like behavior
#   - Persistence disabled by default (enable for testing)
#   - TCP keepalive to detect dead connections
#
# PRODUCTION NOTES:
#   - Increase maxmemory based on available RAM
#   - Enable persistence (AOF/RDB) for durability
#   - Configure replication for high availability
#   - Add authentication with requirepass
#   - Bind to specific interfaces, not 0.0.0.0

# ============================================================================
# NETWORK
# ============================================================================

# Bind to all interfaces inside container
# Docker compose handles external binding to localhost
bind 0.0.0.0

# TCP listen() backlog
tcp-backlog 511

# Close connection after client idle for N seconds (0 = disable)
timeout 300

# TCP keepalive to detect dead peers
# Recommended: 60 seconds (Linux default is much higher)
tcp-keepalive 60

# ============================================================================
# MEMORY MANAGEMENT
# ============================================================================

# Maximum memory limit for Redis
# Default: 512MB (suitable for dev laptops)
# Production: Set to ~70% of available RAM
# 
# Examples:
#   - Small cache: 512mb
#   - Medium cache: 2gb
#   - Large cache: 8gb
maxmemory 512mb

# Eviction policy when maxmemory is reached
# 
# Options:
#   - volatile-lru: Evict LRU keys with TTL set (RECOMMENDED for cache)
#   - allkeys-lru: Evict any key using LRU (use if most data is cache)
#   - volatile-lfu: Evict LFU keys with TTL (Redis 4.0+)
#   - allkeys-lfu: Evict any key using LFU
#   - volatile-random: Evict random keys with TTL
#   - allkeys-random: Evict random keys
#   - volatile-ttl: Evict keys with nearest expire time
#   - noeviction: Return errors when memory limit reached
#
# RECOMMENDATION: Use volatile-lru for mixed workloads (cache + persistent data)
#                 Use allkeys-lru for pure cache use case
maxmemory-policy volatile-lru

# LRU/LFU sample size for eviction algorithm
# Higher = more accurate but slower
# Default: 5 (good balance)
maxmemory-samples 5

# ============================================================================
# PERSISTENCE (DISABLED FOR DEV)
# ============================================================================

# Disable RDB snapshots for development
# Production: Enable with "save 900 1" (save after 900s if 1 key changed)
save ""

# Disable AOF (Append Only File) for development
# Production: Enable with "appendonly yes" for durability
appendonly no

# AOF sync policy (if enabled)
# Options: always (slow, safe), everysec (balanced), no (fast, risky)
# appendfsync everysec

# ============================================================================
# REPLICATION (NOT USED IN LOCAL DEV)
# ============================================================================

# Replica configuration (if this instance is a replica)
# replicaof <masterip> <masterport>

# Replica serves stale data during initial sync
replica-serve-stale-data yes

# Replica is read-only
replica-read-only yes

# ============================================================================
# SECURITY
# ============================================================================

# Require password (DISABLED for local dev)
# Production: ALWAYS set this
# requirepass your_strong_password_here

# Rename dangerous commands (optional security hardening)
# rename-command FLUSHDB ""
# rename-command FLUSHALL ""
# rename-command CONFIG ""

# ============================================================================
# LIMITS
# ============================================================================

# Max number of connected clients
maxclients 10000

# ============================================================================
# SLOW LOG
# ============================================================================

# Log queries slower than N microseconds
# 10000 = 10ms (log slow queries for performance analysis)
slowlog-log-slower-than 10000

# Keep last N slow log entries
slowlog-max-len 128

# ============================================================================
# LATENCY MONITOR
# ============================================================================

# Enable latency monitoring (0 = disabled)
# Production: Set to 100 (log events slower than 100ms)
latency-monitor-threshold 0

# ============================================================================
# EVENT NOTIFICATION (Optional)
# ============================================================================

# Keyspace notifications (disabled by default)
# Enable to receive pub/sub events on key operations
# 
# Options:
#   K - Keyspace events (published to __keyspace@<db>__:<key>)
#   E - Keyevent events (published to __keyevent@<db>__:<event>)
#   g - Generic commands (DEL, EXPIRE, RENAME, etc)
#   $ - String commands
#   l - List commands
#   s - Set commands
#   h - Hash commands
#   z - Sorted set commands
#   x - Expired events
#   e - Evicted events
#   A - Alias for "g$lshzxe"
#
# Example: "Ex" for evicted and expired events
# notify-keyspace-events ""

# ============================================================================
# ADVANCED CONFIG
# ============================================================================

# Hash encoding (space-efficient for small hashes)
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

# List encoding
list-max-ziplist-size -2
list-compress-depth 0

# Set encoding
set-max-intset-entries 512

# Sorted set encoding
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

# HyperLogLog sparse representation
hll-sparse-max-bytes 3000

# Stream data structure parameters
stream-node-max-bytes 4096
stream-node-max-entries 100

# Active rehashing
activerehashing yes

# Client output buffer limits
# client-output-buffer-limit normal 0 0 0
# client-output-buffer-limit replica 256mb 64mb 60
# client-output-buffer-limit pubsub 32mb 8mb 60

# Frequency of background tasks (1-500, higher = more CPU, lower latency)
hz 10

# Enable dynamic hz (adjusts based on connected clients)
dynamic-hz yes

# AOF rewrite incremental fsync
aof-rewrite-incremental-fsync yes

# RDB incremental fsync
rdb-save-incremental-fsync yes

# ============================================================================
# TUNING NOTES
# ============================================================================
#
# For cache workloads:
#   1. Set maxmemory to 70-80% of available RAM
#   2. Use volatile-lru or allkeys-lru eviction
#   3. Disable persistence (save "") for max performance
#   4. Monitor hit rate: INFO stats | grep keyspace_hits
#   5. Tune maxmemory-samples (higher = better eviction, more CPU)
#
# For persistent workloads:
#   1. Enable AOF: appendonly yes, appendfsync everysec
#   2. Enable RDB: save 900 1
#   3. Use volatile-lru (never evict non-expiring keys)
#   4. Monitor replication lag in multi-node setups
#
# Performance tips:
#   - Use pipelining for bulk operations
#   - Avoid KEYS command in production (use SCAN)
#   - Monitor slow log regularly
#   - Keep values small (<100KB per key)
#   - Use appropriate data structures (hash for objects, not strings)